%! suppress = GatherEquations
\documentclass{article}[11pt]

% ---------------------------------- DEBUT EXTENSIONS

\newcommand{\invisible}[1] { }

\newtheorem{prop}{Proposition}
\newtheorem{corol}{Corollaire}
\newtheorem{lemme}{Lemme}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\newcommand{\epsffig}[3]
{
    \begin{figure}[hbt]
        \centerline{\epsffile{#1.eps}}
        \caption{\label{#2}{#3}}
    \end{figure}
}

\newcommand{\subsubsubsection}[1]
{
    ~\\
    {\bf {\em #1}} \\
}

\newcommand{\downtree}[1]
{
    \begin{tabular}{c}
        \vspace{0.1mm} \\
        {\small\({\rm #1}\)} \\
    \end{tabular}
}

\newcommand{\leaf}[1]
{
    \regle{}{#1}
}

\newcommand{\Class}[1]{\langle\kern-1mm\langle{#1}\rangle\kern-1mm\rangle}
\newcommand{\Rec}[1]{\{\kern-1mm\{{#1}\}\kern-1mm\}}
\newcommand{\Obj}[1]{\langle{#1}\rangle}
\newcommand{\ObjT}[1]{\langle\kern-.5mm\langle{#1}\rangle\kern-.5mm\rangle}
\newcommand{\Spe}[1]{[\kern-.5mm[{#1}]\kern-.5mm]}
\newcommand{\NSpe}[2]{{\cal #1}\Spe{#2}}
\newcommand{\Card}[1]{|\kern-.5mm|{#1}|\kern-.5mm|}
\newcommand{\CardF}[1]{|\kern-.5mm|{#1}|\kern-.5mm|^f}
\newcommand{\squetch}[1]{\begin{flushright}
                             #1
\end{flushright}}

% \newtheorem{lemme}{Lemme}
% \newtheorem{definition}{Definition}

\newcommand{\crtdef}[1]
{
        {\small
        \begin{center}
            \begin{tabular}{p{8cm}}
                $\ulcorner\hfill\urcorner$ \\
                #1                         \\
                $\llcorner\hfill\lrcorner$ \\
            \end{tabular}
        \end{center}
    }
}

\newcommand{\crtdefblock}[1]
{
    \begin{figure\star}[hbt]
    {\small
        \begin{center}
            \begin{tabular}{c}
                $\ulcorner\hfill\urcorner$ \\
                #1                         \\
                $\llcorner\hfill\lrcorner$ \\
            \end{tabular}
        \end{center}
    }
    \end{figure\star}
}

\newcommand{\crt}[1]
{
        {\small
        \begin{center}
            \begin{tabular}{p{8cm}}
                #1 \\
            \end{tabular}
        \end{center}
    }
}

\newcommand{\term}[1]{\verb~#1~}
\newcommand{\cons}[1]{\underline{\verb~#1~}}
\newcommand{\lambe}[0]{{\sf Lamb\"e~}}

% ------------------------------------ FIN EXTENSIONS

\usepackage{amssymb}
\usepackage{trfrac}

\begin{document}

    \title{The \lambe programming language}
    \author{D. Plaindoux}

    \maketitle


    \section{Kind level}\label{sec:kind-level}

    \begin{math}
        \begin{array}{rcll}
            \kappa
            & =    & \star                    \\
            & \mid & \star \rightarrow \kappa
        \end{array}
    \end{math}


    \section{Type level}\label{sec:type-level}

    \begin{math}
        \begin{array}{rclp{5cm}}
            \underline{c} & \in & {\cal C} \\
            m & \in & {\cal I} \\
            \tau & =
            & \alpha & Variable \\
            & \mid & m                            & Constant                   \\
            & \mid & \tau \rightarrow \tau        & Function                   \\
            & \mid & \tau \looparrowright \tau    & Method                     \\
            & \mid & \tau~\tau                    & Application                \\
            & \mid & \tau + \tau                  & Sum~type                   \\
            & \mid & \forall (\alpha:\kappa).\tau & Universal~Quantification   \\
            & \mid & \exists (\alpha:\kappa).\tau & Existential~Quantification \\
            & \mid & \mu(\alpha).\tau             & Recursion                  \\
            & \mid & \underline{c} S              & Constructor                \\
            & \mid & \Gamma                       & Trait                      \\
        \end{array}
    \end{math}


    \section{Trait level}\label{sec:trait-level}

    \begin{math}
        \begin{array}{rclp{5cm}}
            k, t, m & \in & {\cal I}                          \\
            K       & =   & \{ m_i : \kappa_i \}_I            \\
            T       & =   & \{ m_i \triangleq \tau_i \}_I     \\
            S       & =   & \{ m_i : \tau_i \}_I              \\
            W       & =   & \{ \sigma_i \}_I                  \\
            M       & =   & \{ m_i \triangleq \epsilon_i \}_I \\
            \Gamma  & =   & \langle K, T, S, W \rangle        \\
            \Sigma  & =   & \Gamma \circledast M
        \end{array}
    \end{math}


    \section{Expression level}\label{sec:expression-level}

    \begin{math}
        \begin{array}{rclp{5cm}}
            \underline{c} & \in & {\cal C} \\
            m & \in & {\cal I} \\
            \epsilon & =
                   & \alpha                                                                  & Variable        \\
            & \mid & m                                                                       & Constant        \\
            & \mid & \lambda \alpha . \epsilon                                               & Abstraction     \\
            & \mid & \epsilon~\epsilon                                                       & Application     \\
            & \mid & \epsilon . \epsilon                                                     & Access          \\
            & \mid & \term{let}~\alpha ~ \term{=} ~ \epsilon ~\term{in}~\epsilon             & Let~binding     \\
            & \mid & \term{let}~\term{use} ~ \epsilon ~\term{in}~\epsilon                    & Let~use~binding \\
            & \mid & \term{when}(\alpha).\{ \tau_i \rhd \epsilon_i \}_I                      & Smart cast      \\
            & \mid & \Sigma                                                                  & Trait~term      \\
            & \mid & \{\tau, \epsilon\}                                                      & Pack            \\
            & \mid & \term{let} ~ \{\tau, \alpha\} ~ \term{=} ~ \epsilon ~\term{in}~\epsilon & Unpack          \\
        \end{array}
    \end{math}


    \section{Illustration}\label{sec:illustration}

    \subsection{Algebraic datatype}\label{subsec:algebraic-datatype}

    \begin{verbatim}
type Nil  = data Nil
type Cons = forall a.data Cons (head:a) (tail:List a)
type List = forall a.Nil | Cons a
    \end{verbatim}

    \subsubsubsection{Type kind}

    \noindent\begin{math}
                 \term{Nil}~ : \star \\
                 \term{Cons} : \star \rightarrow \star \\
                 \term{List} : \star \rightarrow \star
    \end{math}

    \subsubsubsection{Type definition}

    \noindent\begin{math}
                 \term{Nil}~ \triangleq \cons{Nil}\{\} \\
                 \term{Cons} \triangleq \forall(\alpha:\star).\mu(X).\cons{Cons}\{ \term{head} :\alpha; \term{tail} : \cons{Nil}\{\} + X \} \\
                 \term{List} \triangleq \forall(\alpha:\star).\mu(X).\cons{Nil}\{\} + \cons{Cons}\{ \term{head} :\alpha; \term{tail} : X \}
    \end{math}

    \subsubsubsection{Function definition}

    \noindent\begin{math}
                 \term{Nil} : \term{Nil} \\
                 \term{Cons} : \forall(\alpha:\star).\alpha \rightarrow \term{List}~\alpha \rightarrow \term{Cons} ~ \alpha \\
    \end{math}

    \subsection{Function signature}\label{subsec:function-signature}

    \begin{verbatim}
sig emptyList : forall a. unit -> List a
sig isEmpty : forall a. self -> bool for List a
    \end{verbatim}

    \noindent\begin{math}
                 \term{emptyList} : \forall(\alpha:\star).\term{unit} \rightarrow \term{List}~\alpha \\
                 \term{isEmpty} : \forall(\alpha:\star).\term{List}~\alpha \looparrowright \term{bool}
    \end{math}

    \subsection{Closed trait}\label{subsec:closed-trait}

    \begin{verbatim}
trait Access a for List a {
    sig head : self -> Option a
}
    \end{verbatim}

    \begin{verbatim}
type Access = forall a. trait for List a {
    sig head : self -> Option a
}
    \end{verbatim}

    \noindent\begin{math}
                 \term{Access} \triangleq \forall(\alpha:\star).\langle
                 \emptyset,
                 \emptyset,
                 \{ \term{head} : \term{List}~\alpha \looparrowright \term{Option}~\alpha \},
                 \emptyset
                 \rangle
    \end{math}

    \subsection{Open trait}

    \begin{verbatim}
trait Set a {
    sig new : self
    sig contains : self -> a -> bool
}
    \end{verbatim}

    \noindent
    \begin{math}
        \term{Set} \triangleq \forall(\alpha:\star).\exists(\term{self}:\star).\langle
        \emptyset,
        \emptyset,
        \{ \term{new} : \term{self}, \term{contains} : \term{self} \looparrowright \alpha \rightarrow bool \},
        \emptyset
        \rangle
    \end{math}

    \subsection{Trait with and abstract type}

    \begin{verbatim}
trait Pure a {
    kind t = type -> type
    sig pure : a -> t a
}
    \end{verbatim}

    \noindent
    \begin{math}
        \term{Pure} \triangleq \forall(\alpha:\star).\exists(\term{t}:\star \rightarrow \star).\langle
        \emptyset,
        \emptyset,
        \{ \term{pure} : \alpha \rightarrow \term{t}~\alpha \},
        \emptyset
        \rangle
    \end{math}

    \subsection{Trait with requirement}\label{subsec:trait-with-requirement}

    \begin{verbatim}
trait Applicative (t:type->type) with Functor t {
    sig  pure : a -> t a
}
    \end{verbatim}

    \noindent
    \begin{math}
        \term{Applicative} \triangleq \forall(\term{t}:\star \rightarrow \star).
        \langle
        \emptyset,
        \emptyset,
        \{ \term{pure} : \alpha \rightarrow \term{t}~\alpha \},
        \{ \term{Functor}~\term{t} \}
        \rangle
    \end{math}


    \section{Type system}\label{sec:type-system}

    \subsection{$\Gamma$ and projections}\label{subsec:gamma-and-projections}

    \begin{math}
        \begin{array}{rcl}
            \Gamma       & = & \gamma \\
            {\cal K}_\downarrow[\_] & : & \Gamma \rightarrow K \\
            {\cal K}_\uparrow[\_] & : & K \rightarrow \Gamma \\
            {\cal T}_\downarrow[\_] & : & \Gamma \rightarrow T \\
            {\cal T}_\uparrow[\_] & : & T \rightarrow \Gamma \\
            {\cal S}[\_] & : & \Gamma \rightarrow S \\
        \end{array}
    \end{math}

    \subsection{Kind inclusion}\label{subsec:kind-inclusion}

    \[\trfrac[]
    {}
    {k \subseteq_\kappa \star}\]

    \[\trfrac[]
    {k' \subseteq_\kappa k}
    {\star \rightarrow k' \subseteq_\kappa \star \rightarrow k}\]

    \subsection{Type rules}\label{subsec:type-rules}

    \[\trfrac[(Identity)]
    {{\cal K}_\downarrow[\Gamma][t] = k' ~~~ k \subseteq_\kappa k'}
    {\Gamma \vdash t :_\kappa k}\]

    \[\trfrac[(apply-type)]
    {\Gamma \vdash t_1 :_\kappa \star \rightarrow k ~~~ \Gamma \vdash t_2 :_\kappa \star}
    {\Gamma \vdash t_1 ~ t_2 :_\kappa k}\]

    \subsection{Type inclusion}\label{subsec:subtyping-rules}

    \[\trfrac[(sub-refl)]
    {\Gamma \vdash t :_\kappa \star}
    {\Gamma \vdash t \subseteq t}\]

    \[\trfrac[(sub-$\rightarrow$)]
    {\Gamma \vdash t_3 \subseteq t_1 ~~~ \Gamma \vdash t_2 \subseteq t_4}
    {\Gamma \vdash t_1 \rightarrow t_2 \subseteq t_3 \rightarrow t_4}\]

    \[\trfrac[(sub-$\looparrowright$)]
    {\Gamma \vdash t_3 \looparrowright t_1 ~~~ \Gamma \vdash t_2 \looparrowright t_4}
    {\Gamma \vdash t_1 \looparrowright t_2 \subseteq t_3 \looparrowright t_4}\]

    \[\trfrac[(sub-+1)]
    {\Gamma \vdash t_1 \subseteq t_2}
    {\Gamma \vdash t_1 \subseteq t_2 + t_3}\]

    \[\trfrac[(sub-+2)]
    {\Gamma \vdash t_1 \subseteq t_3}
    {\Gamma \vdash t_1 \subseteq t_2 + t_3}\]

    \[\trfrac[(sub-$\mu$)]
    {\Gamma \vdash t_1 \subseteq t_2}
    {\Gamma \vdash \mu(X).t_1 \subseteq \mu(X).t_2}\]

    \[\trfrac[(sub-$\mu$-unfold1)]
    {\Gamma \vdash t_1[\mu(X).t_1/X] \subseteq t_2}
    {\Gamma \vdash \mu(X).t_1 \subseteq t_2}\]

    \[\trfrac[(sub-$\mu$-unfold2)]
    {\Gamma \vdash t_1 \subseteq t_2[\mu(X).t_2/X]}
    {\Gamma \vdash t_1 \subseteq \mu(X).t_2}\]

    \[\trfrac[(sub-const)]
    {\forall i \in I, \Gamma \vdash t_i \subseteq t'_i}
    {\Gamma \vdash \cons{c}\{ m_i : t_i \}_I  \subseteq \cons{c}\{ m_i : t'_i \}_I }\]

    \[\trfrac[(sub-$\forall$)]
    {\forall i \in I, \Gamma \oplus {\cal K}_\uparrow[\{ x: k \}] \vdash t_1 \subseteq t_2}
    {\Gamma \vdash \forall(x:k).t_1 \subseteq \forall(x:k).t_2 }\]

    \[\trfrac[(sub-$\exists$)]
    {\forall i \in I, \Gamma \oplus {\cal K}_\uparrow[\{ x: k \}] \vdash t_1 \subseteq t_2}
    {\Gamma \vdash \exists(x:k).t_1 \subseteq \exists(x:k).t_2 }\]

    \subsection{Expression rules}\label{subsec:expression-rules}

    \[\trfrac[(identity)]
    {{\cal S}_\downarrow[\Gamma][e] = t' ~~~ \Gamma \vdash t \subseteq t'}
    {\Gamma \vdash e : t} \]

    \[\trfrac[(apply)]
    {\Gamma \vdash n : t_1 \rightarrow t_2 ~~~ \Gamma \vdash a : t_3 ~~~ \Gamma \vdash t_3 \subseteq t_1}
    {\Gamma \vdash n~a : t_2} \]

    \[\trfrac[(invoke)]
    {\Gamma \vdash n : t_1 \looparrowright t_2 ~~~ \Gamma \vdash a : t_3 ~~~ \Gamma \vdash t_3 \subseteq t_1}
    {\Gamma \vdash a~n : t_2} \]

    \[\trfrac[(abstr)]
    {\Gamma \oplus {\cal T}_\uparrow[\{ n : t_1 \}] \vdash a : t_2}
    {\Gamma \vdash \lambda n.a : t_1 \rightarrow t_2} \]

    \[\trfrac[(const-access)]
    {\Gamma \vdash r : \underline{c} S ~~~ S[n] = t' ~~~ \Gamma \vdash t \subseteq t'}
    {\Gamma \vdash r.n : t} \]

    \[\trfrac[(trait-access)]
    {\Gamma \vdash r : \langle \_, \_ ,S, \_ \rangle ~~~ S[n] = t' ~~~ \Gamma \vdash t \subseteq t'}
    {\Gamma \vdash r.n : t} \]

    \[\trfrac[(trait-access)]
    {\Gamma \vdash r : \langle \_, \_ ,\_, W \rangle ~~~ \exists \gamma \circledast M \in W, \gamma \vdash r.n : t}
    {\Gamma \vdash r.n : t} \]

    \[\trfrac[($\forall$-elim)]
    {\Gamma \vdash e : \forall (a:k).t1 ~~~ \Gamma \vdash t_a : k }
    {\Gamma \vdash e : t[t_a/a]} \]

    \[\trfrac[($\forall$-intro)]
    {\Gamma \oplus {\cal K}_\uparrow[\{ a : k \}] \vdash e : t}
    {\Gamma \vdash e : \forall (a:k).t} \]

    \[\trfrac[($\exists$-elim)]
    {\Gamma \vdash e_1 : \forall (a:k).t_1 ~~~ \Gamma \oplus {\cal K}_\uparrow[\{ A : k \}] \oplus {\cal T}_\uparrow[\{ a : t_1 \}] \vdash e_2 : t_2 ~~~ A \not\in \term{ftv}(t_2)}
    {\Gamma \vdash \term{let} ~ \{A, a\} ~ = e_1 ~ \term{in} ~ e_2 : t_2} \]

    \[\trfrac[($\exists$-intro)]
    {\Gamma \vdash t_1 : k ~~~ \Gamma \vdash e : t_2[t_1/a]}
    {\Gamma \vdash \{t_1,e\} : \exists (a:k).t_2} \]

    \[\trfrac[(let-=)]
        {\Gamma \vdash e_1 : t1 ~~~ \Gamma \oplus {\cal T}_\uparrow[\{ a : t_1 \}] \vdash e_2 : t_2}
        {\Gamma \vdash \term{let} ~ a ~ \term{=} ~ e_1 ~ \term{in} ~ e_2 : t_2} \]

    \[\trfrac[(let-use)]
    {\Gamma \vdash e_1 : \langle K, T, S, W \rangle ~~~ \Gamma \oplus \langle K, T, S, W \rangle \vdash e_2 : t}
    {\Gamma \vdash \term{let use} ~ e_1 ~ \term{in} ~ e_2 : t} \]

    \[\trfrac[(when)]
    {\forall i \in I, \Gamma \vdash a : t_i ~~~ \Gamma \oplus {\cal T}_\uparrow[\{ a : t_i \}] \vdash e_i : t }
    {\Gamma \vdash \term{when}(a).\{ t_i \rhd e_i \}_I : t} \]

    \[\trfrac[(trait)]
    {\forall i \in I, \Gamma \oplus \gamma \vdash e_i : {\cal S}[\gamma][m_i] }
    {\Gamma \vdash \gamma \circledast \{ m_i \triangleq e_i \}_I : \gamma } \]

\end{document}
