%! suppress = GatherEquations
\documentclass{article}[11pt]

% ---------------------------------- DEBUT EXTENSIONS

\newcommand{\invisible}[1] { }

\newtheorem{prop}{Proposition}
\newtheorem{corol}{Corollaire}
\newtheorem{lemme}{Lemme}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\newcommand{\epsffig}[3]
{
    \begin{figure}[hbt]
        \centerline{\epsffile{#1.eps}}
        \caption{\label{#2}{#3}}
    \end{figure}
}

\newcommand{\subsubsubsection}[1]
{
    ~\\
    {\bf {\em #1}} \\
}

\newcommand{\downtree}[1]
{
    \begin{tabular}{c}
        \vspace{0.1mm} \\
        {\small\({\rm #1}\)} \\
    \end{tabular}
}

\newcommand{\leaf}[1]
{
    \regle{}{#1}
}

\newcommand{\Class}[1]{\langle\kern-1mm\langle{#1}\rangle\kern-1mm\rangle}
\newcommand{\Rec}[1]{\{\kern-1mm\{{#1}\}\kern-1mm\}}
\newcommand{\Obj}[1]{\langle{#1}\rangle}
\newcommand{\ObjT}[1]{\langle\kern-.5mm\langle{#1}\rangle\kern-.5mm\rangle}
\newcommand{\Spe}[1]{[\kern-.5mm[{#1}]\kern-.5mm]}
\newcommand{\NSpe}[2]{{\cal #1}\Spe{#2}}
\newcommand{\Card}[1]{|\kern-.5mm|{#1}|\kern-.5mm|}
\newcommand{\CardF}[1]{|\kern-.5mm|{#1}|\kern-.5mm|^f}
\newcommand{\squetch}[1]{\begin{flushright}
                             #1
\end{flushright}}

% \newtheorem{lemme}{Lemme}
% \newtheorem{definition}{Definition}

\newcommand{\crtdef}[1]
{
        {\small
        \begin{center}
            \begin{tabular}{p{8cm}}
                $\ulcorner\hfill\urcorner$ \\
                #1                         \\
                $\llcorner\hfill\lrcorner$ \\
            \end{tabular}
        \end{center}
    }
}

\newcommand{\crtdefblock}[1]
{
    \begin{figure\star}[hbt]
    {\small
        \begin{center}
            \begin{tabular}{c}
                $\ulcorner\hfill\urcorner$ \\
                #1                         \\
                $\llcorner\hfill\lrcorner$ \\
            \end{tabular}
        \end{center}
    }
    \end{figure\star}
}

\newcommand{\crt}[1]
{
        {\small
        \begin{center}
            \begin{tabular}{p{8cm}}
                #1 \\
            \end{tabular}
        \end{center}
    }
}

\newcommand{\term}[1]{\verb~#1~}
\newcommand{\cons}[1]{\underline{\verb~#1~}}
\newcommand{\lambe}[0]{{\sf Lamb\"e~}}

% ------------------------------------ FIN EXTENSIONS

\usepackage{amssymb}
\usepackage{trfrac}

\begin{document}

    \title{The \lambe programming language}
    \author{D. Plaindoux}

    \maketitle


    \section{Kind level}\label{sec:kind-level}

    \begin{math}
        \begin{array}{rcll}
            \kappa
            & =    & \star                    \\
            & \mid & \star \rightarrow \kappa
        \end{array}
    \end{math}


    \section{Type level}\label{sec:type-level}

    \begin{math}
        \begin{array}{rclp{5cm}}
            \underline{c} & \in & {\cal C} \\
            m & \in & {\cal I} \\
            \tau & =
            & \alpha & Variable \\
            & \mid & m                            & Constant                   \\
            & \mid & \tau \rightarrow \tau        & Function                   \\
            & \mid & \tau \looparrowright \tau    & Method                     \\
            & \mid & \tau~\tau                    & Application                \\
            & \mid & \tau + \tau                  & Sum~type                   \\
            & \mid & \forall (\alpha:\kappa).\tau & Universal~Quantification   \\
            & \mid & \exists (\alpha:\kappa).\tau & Existential~Quantification \\
            & \mid & \underline{c} S              & Constructor                \\
            & \mid & \sigma                       & Trait                      \\
        \end{array}
    \end{math}


    \section{Trait level}\label{sec:trait-level}

    \begin{math}
        \begin{array}{rclp{5cm}}
            k, t, m & \in & {\cal I}                          \\
            K       & =   & \{ m_i : \kappa_i \}_I            \\
            T       & =   & \{ m_i \triangleq \tau_i \}_I     \\
            S       & =   & \{ m_i : \tau_i \}_I              \\
            W       & =   & \{ \sigma_i \}_I                  \\
            M       & =   & \{ m_i \triangleq \epsilon_i \}_I \\
            \gamma  & =   & \langle K, T, S, W \rangle        \\
            \sigma  & =   & \gamma \circledast M
        \end{array}
    \end{math}


    \section{Expression level}\label{sec:expression-level}

    \begin{math}
        \begin{array}{rclp{5cm}}
            \underline{c} & \in & {\cal C} \\
            m & \in & {\cal I} \\
            \epsilon & =
            & \alpha & Variable \\
            & \mid & m                                                                       & Constant        \\
            & \mid & \lambda \alpha . \epsilon                                               & Abstraction     \\
            & \mid & \epsilon~\epsilon                                                       & Application     \\
            & \mid & \epsilon . \epsilon                                                     & Access          \\
            & \mid & \term{let}~\alpha ~ \term{=} ~ \epsilon ~\term{in}~\epsilon             & Let~binding     \\
            & \mid & \term{let}~\term{use} ~ \epsilon ~\term{in}~\epsilon                    & Let~use~binding \\
            & \mid & \term{when}(\alpha).\{ \tau_i \rhd \epsilon_i \}_I                      & Smart cast      \\
            & \mid & \sigma                                                                  & Trait~term      \\
            & \mid & \{\tau, \epsilon\}                                                      & Pack            \\
            & \mid & \term{let} ~ \{\tau, \alpha\} ~ \term{=} ~ \epsilon ~\term{in}~\epsilon & Unpack          \\
        \end{array}
    \end{math}


    \section{Illustration}\label{sec:illustration}

    \subsection{Algebraic datatype}\label{subsec:algebraic-datatype}

    \begin{verbatim}
data Nil
data Cons a { head: a; tail: List a }
data List a = Nil | Cons a
    \end{verbatim}

    \subsubsubsection{Type kind}

    \noindent\begin{math}
                 \term{Nil} : \star \\
                 \term{Cons} : \star \rightarrow \star \\
                 \term{List} : \star \rightarrow \star
    \end{math}

    \subsubsubsection{Type definition}

    \noindent\begin{math}
                 \term{Nil} \triangleq \cons{Nil}\{\} \\
                 \term{Cons} \triangleq \forall(\alpha:\star).\cons{Cons}\{ \term{head} :\alpha; \term{tail} : \term{List}~\alpha \} \\
                 \term{List} \triangleq \forall(\alpha:\star).\term{Nil} + \term{Cons}~\alpha
    \end{math}

    \subsubsubsection{Function definition}

    \noindent\begin{math}
                 \term{Nil} : \term{Nil} \\
                 \term{Cons} : \forall(\alpha:\star).\alpha \rightarrow \term{List}~\alpha \rightarrow \term{Cons} ~ \alpha \\
    \end{math}

    \subsection{Function signature}\label{subsec:function-signature}

    \begin{verbatim}
sig isEmpty : forall a. self -> bool for List a
    \end{verbatim}

    \noindent\begin{math}
                 \term{isEmpty} : \forall(\alpha:\star).\term{List}~\alpha \looparrowright \term{bool}
    \end{math}

    \subsection{Closed trait}\label{subsec:closed-trait}

    \begin{verbatim}
trait Access a for List a {
    sig head : self -> Option
}
    \end{verbatim}

    \noindent\begin{math}
                 \term{Access} \triangleq \forall(\alpha:\star).\langle
                 \emptyset,
                 \emptyset,
                 \{ \term{head} : (\term{List}~\alpha) \looparrowright \alpha \},
                 \emptyset
                 \rangle
    \end{math}

    \subsection{Open trait}

    \begin{verbatim}
trait Set a {
    sig new : self
    sig contains : self -> a -> bool
}
    \end{verbatim}

    \noindent
    \begin{math}
        \term{Set} \triangleq \forall(\alpha:\star).\exists(\term{self}:\star).\langle
        \emptyset,
        \emptyset,
        \{ \term{new} : \term{self}, \term{contains} : \term{self} \looparrowright \alpha \rightarrow bool \},
        \emptyset
        \rangle
    \end{math}

    \subsection{Trait with and abstract type}

    \begin{verbatim}
trait Pure a {
    kind t = type -> type
    sig pure : a -> t a
}
    \end{verbatim}

    \noindent
    \begin{math}
        \term{Pure} \triangleq \forall(\alpha:\star).\exists(\term{t}:\star \rightarrow \star).\langle
        \emptyset,
        \emptyset,
        \{ \term{pure} : \alpha \rightarrow \term{t}~\alpha \},
        \emptyset
        \rangle
    \end{math}

    \subsection{Trait with requirement}\label{subsec:trait-with-requirement}

    \begin{verbatim}
trait Applicative (t:type->type) with Functor t
    \end{verbatim}

    \noindent
    \begin{math}
        \term{Applicative} \triangleq \forall(\term{t}:\star \rightarrow \star).\exists(\term{self}:\star).
        \langle
        \emptyset,
        \emptyset,
        \emptyset,
        \{ (\term{Functor}~\term{t}) \}
        \rangle
    \end{math}


    \section{Type system}\label{sec:type-system}

    \subsection{$\Gamma$ and projections}\label{subsec:gamma-and-projections}

    \begin{math}
        \begin{array}{rcl}
            \Gamma       & = & \gamma \\
            {\cal K}[\_] & : & \Gamma \rightarrow K \\
            {\cal S}[\_] & : & \Gamma \rightarrow S \\
        \end{array}
    \end{math}

    \subsection{Kind inclusion}\label{subsec:kind-inclusion}

    \[\trfrac[]
    {}
    {k \subseteq_\kappa \star}\]

    \[\trfrac[]
    {k' \subseteq_\kappa k}
    {\star \rightarrow k' \subseteq_\kappa \star \rightarrow k}\]

    \subsection{Type rules}\label{subsec:type-rules}

    \[\trfrac[(Identity)]
    {{\cal K}[\Gamma][t] = k' ~~~ k \subseteq_\kappa k'}
    {\Gamma \vdash_k t : k}\]

    \[\trfrac[(apply-type)]
    {\Gamma \vdash_k t_1 : \star \rightarrow \star ~~~ \Gamma \vdash_t t_2 : \star}
    {\Gamma \vdash_k t_1 ~ t_2 : \star}\]

    \subsection{Expression rules}\label{subsec:expression-rules}

    \[\trfrac[(+-intro1)]
    {\Gamma \vdash_t e : t_1}
    {\Gamma \vdash_t e : t_1 + t_2} \]

    \[\trfrac[(+-intro2)]
    {\Gamma \vdash_t e : t_2}
    {\Gamma \vdash_t e : t_1 + t_2} \]

    \[\trfrac[(Identity-Type)]
    {{\cal S}[\Gamma][e] = t}
    {\Gamma \vdash_t e : t} \]

    \[\trfrac[(apply)]
    {\Gamma \vdash_t n : t_1 \rightarrow t_2 ~~~ \Gamma \vdash_t a : t_1 }
    {\Gamma \vdash_t n~a : t_2} \]

    \[\trfrac[(invoke)]
    {\Gamma \vdash_t n : t_1 \looparrowright t_2 ~~~ \Gamma \vdash_t a : t_1 }
    {\Gamma \vdash_t a~n : t_2} \]

    \[\trfrac[(abstr)]
    {\Gamma \cup \{ n : t_1 \} \vdash_t a : t_2}
    {\Gamma \vdash_t \lambda n.a : t_1 \rightarrow t_2} \]

    \[\trfrac[(const-access)]
    {\Gamma \vdash_t r : \underline{c} S ~~~ S[n] = t_i}
    {\Gamma \vdash_t r.n : t_i} \]

    \[\trfrac[(trait-access)]
    {\Gamma \vdash_t r : \langle \_, \_ ,S, \_ \rangle ~~~ S[n] = t_i}
    {\Gamma \vdash_t r.n : t_i} \]

    \[\trfrac[(trait-access)]
    {\Gamma \vdash_t r : \langle \_, \_ ,\_, W \rangle ~~~ \exists \gamma \circledast M \in W, \gamma \vdash_t r.n : t}
    {\Gamma \vdash_t r.n : t} \]

    \[\trfrac[($\forall$-elim)]
    {\Gamma \vdash_t e : \forall (a:k).t1 ~~~ \Gamma \vdash_k t_a : k }
    {\Gamma \vdash_t e : t[t_a/a]} \]

    \[\trfrac[($\forall$-intro)]
    {\Gamma \oplus \langle \{ a : k \}, \emptyset, \emptyset, \emptyset \rangle \vdash_t e : t}
    {\Gamma \vdash_t e : \forall (a:k).t} \]

    \[\trfrac[($\exists$-elim)]
    {\Gamma \vdash_t e_1 : \forall (a:k).t_1 ~~~ \Gamma \oplus \langle \{ A : k \}, \emptyset, \{ a : t_1 \}, \emptyset, \emptyset \rangle \vdash_t e_2 : t_2 ~~~ A \not\in \term{ftv}(t_2)}
    {\Gamma \vdash_t \term{let} ~ \{A, a\} ~ = e_1 ~ \term{in} ~ e_2 : t_2} \]

    \[\trfrac[($\exists$-intro)]
    {\Gamma \vdash_k t_1 : k ~~~ \Gamma \vdash_t e : t_2[t_1/a]}
    {\Gamma \vdash_t \{t_1,e\} : \exists (a:k).t_2} \]

    \[\trfrac[(let-=)]
        {\Gamma \vdash_t e_1 : t1 ~~~ \Gamma \oplus \langle \emptyset, \emptyset, \{ a : t_1 \}, \emptyset, \emptyset \rangle \vdash_t e_2 : t_2}
        {\Gamma \vdash_t \term{let} ~ a ~ \term{=} ~ e_1 ~ \term{in} ~ e_2 : t_2} \]

    \[\trfrac[(let-use)]
    {\Gamma \vdash_t e_1 : \langle K, T, S, W \rangle ~~~ \Gamma \oplus \langle K, T, S, W \rangle \vdash_t e_2 : t}
    {\Gamma \vdash_t \term{let use} ~ e_1 ~ \term{in} ~ e_2 : t} \]

    \[\trfrac[(when)]
    {\forall i \in I, \Gamma \vdash_t a : t_i ~~~ \Gamma \oplus \langle \emptyset, \emptyset, \{ a : t_i \}, \emptyset \rangle \vdash_t e_i : t }
    {\Gamma \vdash_t \term{when}(a).\{ t_i \rhd e_i \}_I : t} \]

    \[\trfrac[(trait)]
    {\forall i \in I, \Gamma \oplus \gamma \vdash_t e_i : {\cal S}[\gamma][m_i] }
    {\Gamma \vdash_t \gamma \circledast \{ m_i \triangleq e_i \}_I : \gamma } \]

\end{document}
