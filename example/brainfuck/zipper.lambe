impl lang.list

data Zipper a {
    left    : List a
    right   : List a
    default : a
}

trait zipper a {
    sig new        : a -> self
    sig left       : self -> self
    sig right      : self -> self
    sig current    : self -> a
    sig replace    : self -> (a -> a) -> self
    sig replace_by : self -> a -> self

    def replace_by a = self replace { a }
}

impl zipper a for Zipper a {
    impl lang.pair

    def new default =
        let l = List[default]
        in Zipper l l default

    def left =
        let pair =
            when let l = self left {
            | Nil  -> List[self.default] , $ self.default :: self.right
            | Cons -> l.tail , $ l.head :: self.right
            }
         in self with left = pair._1
                with right = pair._2

    def right =
        let pair =
            when let r = self right {
            | Nil  -> self.default :: self.left , $ List[self.default]
            | Cons -> r.head :: self.left , $ r.tail
            }
        in self with left = pair._1
                with right = pair._2

    def current = self left fold { self default } { $1 head }

    def replace f =
        let value =
            when l = self left {
            | Nil  -> List[ (f self.default) ]
            | Cons -> f l.head :: $ l :: tail
            }
        in self with left = value
}
