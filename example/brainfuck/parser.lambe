use lang.char
use lang.exception
use lang.list
use lang.string
use lang.switch
use lang.predicate

use ast

data BraceMismatch
data StackUnderFlow
data UnknownChar { c:char }
type ParseError = BraceMismatch | StackUnderFlow | UnknownChar

trait Parse {

    sig parse : self -> Program with Exception ParseError

    type ParseContext = Pair Program (Stack Program)

    sig parseChar : self -> ParseContext -> ParseContext for char with Error ParseError
    def parseChar context =
        let program  = context first
        in let programs = context second
        in switch self
            case (equals '>') => { Cursor +1 :: program , programs }
            case (equals '<') => { Cursor -1 :: program , programs }
            case (equals '+') => { Memory +1 :: program , programs }
            case (equals '-') => { Memory -1 :: program , programs }
            case (equals '.') => { Input     :: program , programs }
            case (equals ',') => { Output    :: program , programs }
            case (equals '[') => { List empty           , $ programs push program }
            case (equals ']') => { programs peek fold
                                    { BraceMismatch raise }
                                    { Loop program :: $1.value , $ programs pop }
                                 }
            otherwise         => UnknownChar self raise
}

impl Parser for string {
    def parse =
        let parse i context =
            self chatAt i
            fold { context second peek
                   fold { context first }
                        { BraceMismatch raise }
                 }
                 { self parse (i++) $ $1 value parseChar context }
        in parse 0 $ Nil , $ Stack new

}
