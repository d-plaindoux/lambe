impl algebraic
impl control

data Nil
data (::) a { head : a; tail : List a }
type List a = Nil | (::) a

-- section Constructor

trait Construction {
    trait Builder a {
        sig (]) : List a
        sig (,) : a -> ListBuilder a
    }

    sig ([]) : Nil
    def ([]) = Nil

    data ([) a { value:a }

    impl forall a. Builder a for ([) a {
        def (]) = self.value::Nil
        def (,) a = ListBuilder { (self.value::a::_) }
    }

    data ListBuilder a { value : List a -> List a }

    impl forall a. Builder a for ListBuilder a {
        def (]) = self
        def (,) a = ListBuilder { self.value (a::_) }
    }
}

impl Constructor

-- section Foldable

trait Foldable a s for s {
    sig fold : forall b. self -> b -> (a -> b -> b) -> b
}

impl Foldable a Nil {
    def fold n _ = n
}

impl Foldable a ((::) a) {
    def fold n c = c self.head (self.tail fold n c)
}

impl Foldable a (List a)
    with Foldable a Nil
    with Foldable a ((::) a)

-- section Selectable

trait Selectable a s for s {
    sig select : forall b. self -> (Nil -> b) -> ((::) a -> b) -> b
}

impl Selectable a Nil {
    def select n _ = n self
}

impl Selectable a ((::) a) {
    def select n c = c self
}

impl Selectable a (List a)
    with Selectable a Nil
    with Selectable a ((::) a)

-- section Equatable

trait Equatable a s for s with Equatable a {
    sig (=) : self -> List a -> bool
}

impl Equatable a Nil {
    def (=) l = l fold { true } { false }
}

impl Equatable a ((::) a) {
    def (=) l = l fold { false } { (self.head = l.head) && (self.tail = l.tail) }
}

impl Equatable a (List a)
    with Equatable a Nil
    with Equatable a ((::) a)

-- section Monoid

impl SemiGroup (List a) {
    def compose l =
        when self
        is Nil  -> l
        is (::) -> self.head :: (self.tail compose l)
}

impl Monoid (List a) {
    def neutral = Nil
}

-- operation

trait operation a for List a {
    sig (++) : forall a. self -> self -> self
}

impl forall a. operation a {
    def (++) = self compose
}

-- section Monad

impl forall a. Monad List with Foldable a (List a) {

    def pure a = []

    def product f =
        self fold { Nil } { _.tail <*> $ f map _.head }

    def join =
        self fold { nil } { _.head compose $ _.tail join }
}
