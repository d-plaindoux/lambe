data Nil
data (::) a { head : a; tail : List a }
type List a = Nil | (::) a

-- section Constructor

trait Construction {
    trait Builder a {
        sig (]) : List a
        sig (,) : a -> ListBuilder a
    }

    sig ([]) : Nil
    def ([]) = Nil

    data ([) a { value:a }

    impl forall a. Builder a for ([) a {
        def (]) = self.value::Nil
        def (,) a = ListBuilder { (self.value::a::_) }
    }

    data ListBuilder a { value : List a -> List a }

    impl forall a. Builder a for ListBuilder a {
        def (]) = self
        def (,) a = ListBuilder { self.value (a::_) }
    }
}

impl Constructor

-- section Foldable

trait forall a. Foldable a s for s {
    sig fold : forall b. self -> b -> (a -> b -> b) -> b
}

impl forall a. Foldable a Nil {
    def fold n _ = n
}

impl forall a. Foldable a ((::) a) {
    def fold n c = c self.head (self.tail fold n c)
}

impl forall a. Foldable a (List a)
    with Foldable a Nil
    with Foldable a ((::) a)

-- section Selectable

trait Selectable a s for s {
    sig select : forall b. self -> (Nil -> b) -> ((::) a -> b) -> b
}

impl forall a. Selectable a Nil {
    def select n _ = n self
}

impl forall a. Selectable a ((::) a) {
    def select n c = c self
}

impl forall a. Selectable a (List a)
    with Selectable a Nil
    with Selectable a ((::) a)

-- section Equatable

trait Equatable a s for s with Equatable a {
    sig (=) : self -> List a -> bool
}

impl Equatable a Nil {
    def (=) l = l fold { true } { false }
}

impl Equatable a ((::) a) {
    def (=) l = l fold { false } { (self.head = l.head) && (self.tail = l.tail) }
}

impl Equatable a (List a)
    with Equatable a Nil
    with Equatable a ((::) a)

-- section Monoid

impl forall a. SemiGroup (List a) {
    def compose l =
        when self
        is Nil  -> l
        is (::) -> self.head :: (self.tail compose l) -- Not a really efficient operation I know
}

impl forall a. Monoid (List a) {
    def neutral = Nil
}

-- operation

trait Operation a for List a {
    sig (++) : forall a. self -> self -> self
}

impl forall a. Operation a {
    def (++) = self compose
}

-- section Monad

impl forall a. Monad List with Foldable a (List a) {
    def pure a = []

    def product f =
        self fold { Nil } { _.tail <*> $ f map _.head }

    def join =
        self fold { nil } { _.head compose $ _.tail join }
}

