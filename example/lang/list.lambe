impl algebraic
impl control

data Nil
data (::) a { head : a; tail : List a }
type List a = Nil | Cons a

-- section foldable

trait foldable a s for s {
    sig fold : forall b. self -> (Nil -> b) -> ((::) a -> b) -> b
}

impl foldable a Nil {
    def fold n _ = n self
}

impl foldable a ((::) a) {
    def fold _ c = c self
}

impl foldable a (List a)
    with Foldable a Nil
    with Foldable a ((::) a)

-- section Monoid

impl SemiGroup (List a) {
    def compose l =
        when self
        is Nil  -> l
        is Cons -> self.head :: (self.tail compose l)
}

impl Monoid (List a) {
    def neutral = Nil
}

-- operation

trait operation a for List a {
    sig (++) : forall a. self -> self -> self
}

impl forall a. operation a {
    def (++) = self compose
}

-- section Foldable | such material can be automatically generated

trait Foldable _ {
    sig fold : forall a b. self -> (self -> b) -> ((::) a -> b) -> b
}

impl Foldable self for Nil {
    def fold f _ = f self
}

impl forall a. Foldable self for (::) a {
    def fold _ f = f self
}

impl forall a. Foldable self for List a
    with Foldable Nil
    with Foldable ((::) a)

-- section Monad

impl forall a. Monad List with foldable a (List a) {
    def pure a = a :: Nil

    def product f =
        self fold { Nil } { _.tail <*> $ f map _.head }

    def join =
        self fold { nil } { _.head compose $ _.tail join }
}
