impl algebraic
impl control

data Nil
data (::) a { head : a; tail : List a }
type List a = Nil | Cons a

-- section foldable

trait foldable a s for s {
    sig fold : forall b. self -> (Nil -> b) -> ((::) a -> b) -> b
}

impl foldable a Nil {
    def fold n _ = n self
}

impl foldable a ((::) a) {
    def fold _ c = c self
}

impl foldable a (List a)
    with Foldable a Nil
    with Foldable a ((::) a)

-- miscellaneous

impl forall a. List a {
    sig (++) : forall a. self -> self -> self
    def (++) = self compose
}

-- section Monoid

impl SemiGroup for List a {
    def compose l =
        when self
        is Nil  -> l
        is Cons -> self.head :: (self.tail compose l)
}

impl Monoid for List a {
    def neutral = Nil
}

-- section Foldable | such material can be automatically generated

trait Foldable _ {
    sig fold : forall a b. self -> (self -> b) -> ((::) a -> b) -> b
}

impl Foldable self for Nil {
    def fold f _ = f self
}

impl forall a. Foldable self for (::) a {
    def fold _ f = f self
}

impl forall a. Foldable self for List a
    with Foldable Nil
    with Foldable ((::) a)

-- section Monad

impl Monad List {
    def pure a = a :: Nil

    def product f =
        when self
        is Nil  -> Nil
        is (::) -> self.tail <*> $ f map self.head

    def join =
        when self
        is Nil  -> Nil
        is (::) -> self.head compose (self.tail join)
}
