impl algebraic
impl control

data Nil
data Cons a { head : a; tail : List a }
type List a = Nil | Cons a

impl forall a. List a {
    sig (::) : self -> self -> Cons a for a
    def (::) l = Cons self l

    sig (++) : forall a. self -> self -> self
    def (++) = self compose
}

comment { section Monoid }

impl SemiGroup for List a {
    def compose l =
        when self
        is Nil -> l
        is Cons -> self.head :: (self.tail compose l)
}

impl Monoid for List a {
    def neutral = Nil
}

comment { section Foldable | such material can be automatically generated }

trait Foldable _ {
    sig fold : forall a b. self -> (self -> b) -> (Cons a -> b) -> b
}

impl Foldable self for Nil {
    def fold self f _ = f self
}

impl forall a. Foldable self for Cons a {
    def fold _ f = f self
}

impl forall a. Foldable self for List a
    with Foldable Nil
    with Foldable (Cons a)

comment { section Monad }

impl Monad List {
    def pure a = a :: Nil

    def product f =
        when self
        is Nil  -> Nil
        is Cons -> self.tail <*> $ f map self.head

    def join =
        when self
        is Nil  -> Nil
        is Cons -> self.head compose (self.tail join)
}
