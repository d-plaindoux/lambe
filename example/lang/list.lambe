impl algebraic
impl control

data Nil
data Cons a {
    head : a
    tail : List a
}

type List a = Nil | Cons a

impl for List a {
    sig fold : forall a b. self -> (self -> b) -> (Cons a -> b) -> b
    def fold f _ = f self
}

impl for Cons a {
    sig fold : forall b. self -> (Nil -> b) -> (self -> b) -> b
    def fold _ f = f self
}

impl for List a {
    sig (::) : self -> List a -> Cons a for a
    def (::) l = Cons self l
}

impl Monad List {
    def pure a = a :: Nil

    def (<*>) f =
        when self {
            is Nil  -> Nil
            is Cons -> self tail <*> $ a map $ self head
        }

    def flatten =
        when self {
            is Nil  -> Nil
            is Cons -> // TODO
        }
}

impl forall a. Semigroup (Option a) with Semigroup a {
    def compose b =
        when self {
        is None -> b
        is Some ->
            when b {
            is None -> self
            is Some -> Some $ self.value compose b.value
            }
        }
}

impl forall a. Monoid (Option a) {
    def neutral = None
}
