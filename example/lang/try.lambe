impl control

data Failure { reason : string }
data Success { value  : a }
type Try a = Failure | Success a

impl forall a. Try a {
    sig fold : forall b. self -> (Failure -> b) -> (Success a -> b) -> b

    def fold f s =
        when self
        is Failure -> f self
        is Success -> s self
}

impl Monad Try {
    def pure a = Success a

    def (<*>) a =
        case self fold { Failure $1.reason } { a map $1.value }

    def flatten =
        self fold { Failure $1.reason } { $1.value }
}
