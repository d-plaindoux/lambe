impl control

data None
data Some a { value : a }

type Option a = None | Some a

impl for Option a {
    sig fold : forall b. self -> (None -> b) -> (Some a -> b) -> b

    def fold n s = when self {
        is None -> n
        is Some -> s self
    }
}

impl Monad Option {
    def pure a = Some a

    def (<*>) a =
        when self {
            is None -> None
            is Some -> a map self.value
        }

    def flatten =
        when self {
            is None -> None
            is Some -> self.value
        }
}
