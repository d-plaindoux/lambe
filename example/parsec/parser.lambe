impl lang.bool
impl lang.char
impl lang.selection
impl lang.string

impl response
impl stream

//
// Parser definition
//

trait Parse a {
    sig parse : self -> Stream char -> Response a
}

//
// Predicate based parsers
//

data Satisfy { predicate : char -> bool }

impl Parser char for Satisfy {
    def parse s =
        let p = s next
        in p._1 fold
            { Rejected false }
            { if (self $1)
              then { Accepted $1 p._2 true }
              else { Rejected false }
            }
}

def any : Satisfy
def any = Satisfy { true }

def aChar : char -> Satisfy
def aChar c = Satisfy { c == $1 }

def notChar : char -> Satisfy
def notChar c = Satisfy { c != $1 }

//
// Parser sequence
//

data And a b {
    left  : Parser a
    right : Parser b
}

impl Parser (Pair a b) for And a b {
    def parse s =
        self left parse s fold
            { rl -> Rejected rl.consumed }
            { al -> self right parse a.input fold
                { rr -> Rejected (al.consumed || rr.consumed) }
                { ar -> Accepted (al.value,ar.value) b.input (al.consumed || ar.consumed) }
            }
}

//
// Parser choice
//

data Or a {
    left  : Parser a
    right : Parser a
}

impl Parser a for Or a {
    def parse s =
        self left parse s fold
            { r ->
              if r.consumed
              then { r }
              else { self right parse s }
            }
            id
}

//
// Parser fmap
//

data FMap a b {
    parser : Parser a
    function : a -> b
}

impl Parser b for FMap a b {
    def parse s =
        self left.parser parse s fold
            { Rejected $1.consumed }
            { Accepted (self.function $1) $1.input $1.consumed }
}

// WIP

