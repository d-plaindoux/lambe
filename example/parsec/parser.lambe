impl lang.bool
impl lang.char
impl lang.selection
impl lang.string

impl response
impl stream

//
// Parser definition
//

trait Parse s a {
    sig parse : self -> Stream s -> Response a s
}

//
// Predicate based parsers
//

data Satisfy s {
    predicate : s -> bool
}

impl Parser s s for Satisfy s {
    def parse s =
        let p = s next
        in when let r = p._1 {
           is Rejected -> Rejected false
           is Accepted ->
              if (self predicate r)
              then { Accepted r.value p._2 true }
              else { Rejected false }
           }
}

def any : Satisfy
def any = Satisfy { true }

def aChar : char -> Satisfy
def aChar c = Satisfy { c == $1 }

def notChar : char -> Satisfy
def notChar c = Satisfy { c != $1 }

//
// Parser sequence
//

data And s a b {
    left  : Parser s a
    right : Parser s b
}

impl Parser s (Pair a b) for And s a b {
    def parse s =
        when let r = self left parse s {
        is Rejected -> Rejected r.consumed
        is Accepted ->
            when let l = self right parse r.stream {
                is Rejected -> Rejected r.stream (r.consumed || l.consumed)
                is Accepted -> Accepted (r.value,l.value) b.stream (r.consumed || l.consumed)
            }
        }
}

//
// Parser choice
//

data Or s a {
    left  : Parser s a
    right : Parser s a
}

impl Parser s a for Or s a {
    def parse s =
        when let r = self left parse s {
        is Rejected ->
              if r.consumed
              then { r }
              else { self right parse s }
        is Accepted -> r
        }
}

//
// Parser map
//

data FMap s a b {
    parser : Parser s a
    function : a -> b
}

impl Parser s b for FMap s a b {
    def parse s =
        when let r = self left.parser parse s {
            is Rejected -> Rejected r.stream r.consumed
            is Accepted -> Accepted (self.function r) r.stream r.consumed
        }
}

// WIP

