impl lang.bool
impl lang.char
impl lang.string

//
// Parser response
//

trait Stream s {
    sig next : self -> Option (Pair s self)
}

type Response a s =
  Rejected { consumed : bool }
| Accepted { value    : a
             input    : Stream s
             consumed : bool
           }

impl for Response a {
    sig fold : self -> (Rejected-> b) -> (Accepted a -> b) -> b

    def Rejected.fold f _ = f self
    def Accepted.fold f _ = f self
}

trait Parse a {
    sig parse : self -> Sequence char ->  Response a
}

//
// Predicate based parsers
//

data Satisfy { predicate : char -> bool }

impl Parser char for Satisfy {
    def parse s =
        s next fold
            { Rejected false }
            { if (self $1._1)
              then { Accepted $1._1 $1._2 true }
              else { Rejected false }
            }
}

def any : Satisfy
def any = Satisfy { true }

def aChar : char -> Satisfy
def aChar c = Satisfy { c == $1 }

def notChar : char -> Satisfy
def notChar c = Satisfy { c != $1 }

//
// Parser sequence
//

data And a b {
    left  : Parser a
    right : Parser b
}

impl Parser (Pair a b) for And a b {
    def parse s =
        self left parse s fold
            { rl -> Rejected rl.consumed }
            { al -> self right parse a.input fold
                { rr -> Rejected (al.consumed || rr.consumed) }
                { ar -> Accepted (al.value,ar.value) b.input (al.consumed || ar.consumed) }
            }
}

//
// Parser choice
//

data Or a {
    left  : Parser a
    right : Parser a
}

impl Parser a for Or a {
    def parse s =
        self left parse s fold
            { r ->
              if r.consumed
              then { r }
              else { self right parse s }
            }
            id
}

// WIP

