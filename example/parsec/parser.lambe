impl lang.bool
impl lang.char
impl lang.selection
impl lang.string

impl response
impl stream

trait Parse a {
    sig parse : forall s. self -> Stream s -> Response a s
}

data Satisfy s { predicate : s -> bool }

impl Parser s for Satisfy s {
    def parse s =
        let p = s next
        in when let r = p.fst
           is Rejected -> Rejected false
           is Accepted ->
              if (self predicate r)
              then { Accepted r.value p.snd true }
              else { Rejected false }
}

sig any : Satisfy
def any = Satisfy { true }

sig aChar : char -> Satisfy
def aChar c = Satisfy { c == _ }

sig notChar : char -> Satisfy
def notChar c = Satisfy { c != _ }

data And a b { left  : Parser a; right : Parser b }

impl forall a b. Parser (a * b) for And a b {
    def parse s =
        when let r = self left parse s
        is Rejected -> Rejected r.consumed
        is Accepted ->
            when let l = self right parse r.stream
            is Rejected -> Rejected r.stream (r.consumed || l.consumed)
            is Accepted -> Accepted (r.value,l.value) b.stream (r.consumed || l.consumed)
}

data Or a { left  : Parser a; right : Parser a }

impl forall a. Parser a for Or a {
    def parse s =
        when let r = self left parse s
        is Rejected ->
            if r.consumed
            then { r }
            else { self right parse s }
        is Accepted -> r
}

data FMap a b {
    parser : Parser a;
    function : a -> b
}

impl Parser b for FMap a b {
    def parse s =
        when let r = self left.parser parse s
        is Rejected -> Rejected r.stream r.consumed
        is Accepted -> Accepted (self.function r) r.stream r.consumed
}

