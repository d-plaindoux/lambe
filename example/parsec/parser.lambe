impl lang.bool
impl lang.char
impl lang.selection
impl lang.string

impl response
impl stream

//
// Parser definition
//

trait Parse a {
    sig parse : self -> Stream char -> Response a
}

//
// Predicate based parsers
//

data Satisfy { predicate : char -> bool }

impl Parser char for Satisfy {
    def parse s =
        let p = s next
        in when let r = p._1 {
           is Rejected -> Rejected false
           is Accepted ->
              if (self r)
              then { Accepted e p._2 true }
              else { Rejected false }
           }
}

def any : Satisfy
def any = Satisfy { true }

def aChar : char -> Satisfy
def aChar c = Satisfy { c == $1 }

def notChar : char -> Satisfy
def notChar c = Satisfy { c != $1 }

//
// Parser sequence
//

data And a b {
    left  : Parser a
    right : Parser b
}

impl Parser (Pair a b) for And a b {
    def parse s =
        when let r = self left parse s {
        is Rejected -> Rejected r.consumed
        is Accepted ->
            when let l = self right parse r.input {
                is Rejected -> Rejected (r.consumed || l.consumed)
                is Accepted -> Accepted (r.value,l.value) b.input (r.consumed || l.consumed)
            }
        }
}

//
// Parser choice
//

data Or a {
    left  : Parser a
    right : Parser a
}

impl Parser a for Or a {
    def parse s =
        when let r = self left parse s {
        is Rejected ->
              if r.consumed
              then { r }
              else { self right parse s }
        is Accepted -> r
        }
}

//
// Parser map
//

data FMap a b {
    parser : Parser a
    function : a -> b
}

impl Parser b for FMap a b {
    def parse s =
        when let r = self left.parser parse s {
            is Rejected -> Rejected r.consumed
            is Accepted -> Accepted (self.function r) r.input r.consumed
        }
}

// WIP

